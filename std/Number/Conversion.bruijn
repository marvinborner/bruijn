# MIT License, Copyright (c) 2024 Marvin Borner
# convert bases to other bases

:import std/Combinator .
:import std/Number/Unary U
:import std/Number/Binary B
:import std/Number/Ternary T

# converts unary numbers to ternary
unary→ternary [0 T.inc (+0t)] ⧗ Unary → Ternary

:test (unary→ternary (+0u)) ((+0t))
:test (unary→ternary (+2u)) ((+2t))

# converts ternary numbers to unary
ternary→unary [T.apply 0 U.inc (+0u)] ⧗ Ternary → Unary

:test (ternary→unary (+0t)) ((+0u))
:test (ternary→unary (+2t)) ((+2u))

# converts binary numbers to ternary
# constructs reversed path of composed functions and applies to ternary
binary→ternary [y [[[rec]]] [0] 0 (+0t)] ⧗ Binary → Ternary
	rec B.zero? 0 case-end case-rec
		case-rec B.odd? 0 (2 (1 ∘ T.inc) (B.dec 0)) (2 (1 ∘ (T.mul (+2t))) (B.div² 0))
		case-end 1

:test (T.eq? (binary→ternary (+0b)) (+0t)) ([[1]])
:test (T.eq? (binary→ternary (+42b)) (+42t)) ([[1]])
