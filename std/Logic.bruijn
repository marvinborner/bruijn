# MIT License, Copyright (c) 2022 Marvin Borner

:import std/Combinator .

not [0 false true]

!( not

:test (!true) (false)
:test (!false) (true)

and [[1 0 false]]

(&&) and

:test (true && true) (true)
:test (true && false) (false)
:test (false && true) (false)
:test (false && false) (false)

nand [[1 0 1 false true]]

:test (nand true true) (false)
:test (nand true false) (true)
:test (nand false true) (true)
:test (nand false false) (true)

or [[1 true 0]]

(||) or

:test (true || true) (true)
:test (true || false) (true)
:test (false || true) (true)
:test (false || false) (false)

nor [[1 1 0 false true]]

:test (nor true true) (false)
:test (nor true false) (false)
:test (nor false true) (false)
:test (nor false false) (true)

xor [[1 (not 0) 0]]

:test (xor true true) (false)
:test (xor true false) (true)
:test (xor false true) (true)
:test (xor false false) (false)

xnor [[1 0 (not 0)]]

:test (xnor true true) (true)
:test (xnor true false) (false)
:test (xnor false true) (false)
:test (xnor false false) (true)

# this function is generally redundant
# I personally just write (exp? case-T case-F) directly
if [[[2 1 0]]]

(?!) if

:test (if true true false) (true)
:test ((true ?! true) false) (true)
:test (if false true false) (false)
:test ((false ?! true) false) (false)

implies [[or (not 1) 0]]

(=>?) implies

:test (true =>? true) (true)
:test (true =>? false) (false)
:test (false =>? true) (true)
:test (false =>? false) (true)

iff [[and (implies 1 0) (implies 0 1)]]

(<=>?) iff

:test (true <=>? true) (true)
:test (true <=>? false) (false)
:test (false <=>? true) (false)
:test (false <=>? false) (true)
