# MIT License, Copyright (c) 2022 Marvin Borner

:import std/Combinator .

not [0 F T]

!( not

:test (!T) (F)
:test (!F) (T)

and [[1 0 F]]

(&&) and

:test (T && T) (T)
:test (T && F) (F)
:test (F && T) (F)
:test (F && F) (F)

nand [[1 0 1 F T]]

:test (nand T T) (F)
:test (nand T F) (T)
:test (nand F T) (T)
:test (nand F F) (T)

or [[1 T 0]]

(||) or

:test (T || T) (T)
:test (T || F) (T)
:test (F || T) (T)
:test (F || F) (F)

nor [[1 1 0 F T]]

:test (nor T T) (F)
:test (nor T F) (F)
:test (nor F T) (F)
:test (nor F F) (T)

xor [[1 (not 0) 0]]

:test (xor T T) (F)
:test (xor T F) (T)
:test (xor F T) (T)
:test (xor F F) (F)

xnor [[1 0 (not 0)]]

:test (xnor T T) (T)
:test (xnor T F) (F)
:test (xnor F T) (F)
:test (xnor F F) (T)

if [[[2 1 0]]]

(?!) if

:test (if T T F) (T)
:test ((T ?! T) F) (T)
:test (if F T F) (F)
:test ((F ?! T) F) (F)

implies [[or (not 1) 0]]

(=>?) implies

:test (T =>? T) (T)
:test (T =>? F) (F)
:test (F =>? T) (T)
:test (F =>? F) (T)

iff [[and (implies 1 0) (implies 0 1)]]

(<=>?) iff

:test (T <=>? T) (T)
:test (T <=>? F) (F)
:test (F <=>? T) (F)
:test (F <=>? F) (T)
