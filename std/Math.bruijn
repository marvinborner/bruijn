# MIT License, Copyright (c) 2022 Marvin Borner

:input std/Number

:import std/List .

# adds all values in list
sum foldl add (+0) ⧗ (List Number) → Number

∑‣ sum

:test (∑((+1) : ((+2) : ((+3) : empty)))) ((+6))

# returns max value of list
lmax foldl1 max ⧗ (List Number) → Number

:test (lmax ((+1) : ((+3) : ((+2) : empty)))) ((+3))

# returns min value of list
lmin foldl1 min ⧗ (List Number) → Number

:test (lmin ((+2) : ((+1) : ((+0) : empty)))) ((+0))

# list from num to num
{…→…} z [[[rec]]] ⧗ Number → Number → (List Number)
	rec (1 =? ++0) case-end case-list
		case-list 1 : (2 ++1 0)
		case-end empty

:test ({ (+0) → (+2) }) ((+0) : ((+1) : ((+2) : empty)))

# equivalent of mathematical sum function
∑…→…|… z [[[[[rec]]]]] (+0) ⧗ Number → Number → (Number → Number) → Number
	rec (2 =? ++1) case-end case-sum
		case-sum 4 (3 + (0 2)) ++2 1 0
		case-end 3

:test (∑ (+1) → (+3) | ++‣) ((+9))

# multiplies all values in list
product foldl mul (+1) ⧗ (List Number) → Number

Π product

:test (Π ((+1) : ((+2) : ((+3) : empty)))) ((+6))

# equivalent of mathematical product function
∏…→…|… z [[[[[rec]]]]] (+1) ⧗ Number → Number → (Number → Number) → Number
	rec (2 =? ++1) case-end case-sum
		case-sum 4 (3 ⋅ (0 2)) ++2 1 0
		case-end 3

:test (∏ (+1) → (+3) | ++‣) ((+24))

# greatest common divisor
gcd z [[[(1 =? 0) case-eq ((1 >? 0) case-gre case-les)]]] ⧗ Number → Number → Number
	case-eq 1
	case-gre 2 (1 - 0) 0
	case-les 2 1 (0 - 1)

:test ((gcd (+2) (+4)) =? (+2)) (true)
:test ((gcd (+10) (+5)) =? (+5)) (true)
:test ((gcd (+3) (+8)) =? (+1)) (true)

# power function
pow […!!… (iterate (…⋅… 0) (+1))] ⧗ Number → Number → Number

…**… pow

:test (((+2) ** (+3)) =? (+8)) (true)

# power function using ternary exponentiation (TODO: slow..)
pow' z [[[rec]]] ⧗ Number → Number → Number
	rec =?0 case-end case-pow
		case-pow =?(lst 0) (r ⋅ r ⋅ r) (r ⋅ r ⋅ r ⋅ 1)
			r 2 1 /³0
		case-end (+1)

# prime number sequence
primes nub ((…≠?… (+1)) ∘∘ gcd) (iterate ++‣ (+2)) ⧗ (List Number)

# factorial function
# TODO: faster fac?
fac [∏ (+1) → 0 | i] ⧗ Number → Number

:test ((fac (+3)) =? (+6)) (true)

# fibonacci sequence
# TODO: faster fib?
fibs head <$> (iterate [~0 : (^0 + ~0)] ((+0) : (+1))) ⧗ (List Number)

fib [fibs !! ++0] ⧗ Number

:test (fib (+5)) ((+8))

# pascal triangle
# TODO: something is wrong in here
pascal iterate [zip-with …+… ({}(+0) ++ 0) (0 ; (+0))] ({}(+1))

# π
# q 3, r 2, t 1, i 0
# translation of unbounded spigot algorithm by Jeremy Gibbons
# TODO: Fix/faster
π g (+1) (+180) (+60) (+2) ⧗ (List Number)
	g y [[[[[calc]]]]]
		calc b : (4 q r t i)
			a ↑⁰(↑⁺0 ⋅ (↑⁰0 + (+2)))
			b (3 ⋅ ↑⁰(↑⁻(↑⁻0)) + ((+5) ⋅ 2)) /! ((+5) ⋅ 1)
			q (+10) ⋅ 3 ⋅ 0 ⋅ --((+2) ⋅ 0)
			r (+10) ⋅ a ⋅ (3 ⋅ ((+5) ⋅ 0 - (+2)) + 2 - (b ⋅ 1)
			t 1 ⋅ a
			i ++0
