# MIT License, Copyright (c) 2025 Marvin Borner
# mini forth/postscript-like stack DSL

:import std/Tuples .
:import std/Combinator .
:import std/Number/Unary N

# ============ #
# INSTRUCTIONS #
# ============ #

# ( a -- a a )
dup [1 0 0]

:test ([(`1 : `2 : `3) dup]) (`1 : `1 : `2 : `3)

# ( a -- )
drop [1]

:test ([(`1 : `2 : `3) drop]) (`2 : `3)

# ( a b -- b a )
swap [[2 0 1]]

:test ([(`1 : `2 : `3) swap]) (`2 : `1 : `3)

# ( a b -- a b a )
over [[2 1 0 1]]

:test ([(`1 : `2 : `3) over]) (`1 : `2 : `1 : `3)

# ( a b c -- b c a )
rot [[[3 1 0 2]]]

:test ([(`1 : `2 : `3) rot]) (`2 : `3 : `1)

# ( b t f -- t/f )
ifelse [[[3 (0 1 2)]]]

:test ([(`0 : `1 : [[0]]) ifelse]) (`0 :)
:test ([(`0 : `1 : [[1]]) ifelse]) (`1 :)

# instructions must not be applications, therefore η-expanded
# (see encode-recursively)

add [1 ∘∘ N.add 0]

sub [1 ∘∘ N.sub 0]

mul [1 ∘∘ N.mul 0]

div [1 ∘∘ N.div 0]

# ======== #
# LANGUAGE #
# ======== #

:import std/Meta M

# inserts starting index and abstraction
# (programs must start with a value)
insert-start (y [M.idx : case-app : M.abs]) → M.abs
	case-app [[(M.app? 1) rec end]]
		rec M.app (2 1) 0
		end M.app (M.app `0 1) 0

:test (insert-start `(`0 `1 `2)) (`[0 `0 `1 `2])

# maps indices to Church numbers (syntactic sugar)
map-indices M.map (y [M.idx : case-app : M.abs])
	case-app [[M.app (2 1) (0 case-idx M.app M.abs)]]
		case-idx [M.app `0 (M.abs (M.abs (0 (M.app `1) `0)))]

:test (map-indices `[0 1 2 3]) (`[0 (0 (+1u)) (0 (+2u)) (0 (+3u))])

# inserts nested abstractions to bind free variables in instructions
insert-abstractions M.map (y [M.idx : case-app : M.abs])
	case-app [M.app (M.abs (1 0))]

:test (insert-abstractions `[0 (0 `0) (0 `1) (0 `2)]) (`[[[[0] (0 `0)] (0 `1)] (0 `2)])
:test (M.!(insert-abstractions `[0 (0 `0) (0 `1) (0 `2)])) (`2 : `1 : `0)

# calls the encode function on every application argument and wraps it
encode-recursively [y [M.idx : case-app : M.abs]]
	case-app [[M.app (2 1) (M.app? 0 (M.app `0 (3 (2 0))) 0)]]

encode y [(encode-recursively 0) → insert-start → map-indices → insert-abstractions]

run encode → M.eval

:test (run `(1 2 3)) ((+3u) : (+2u) : (+1u))
:test (run `(1 (2 3) 4)) ((+4u) : ((+3u) : (+2u)) : (+1u))

# TODO: something wrong in encode-recursively?
# :test (run `(1 (2 (3 4)) 5)) ((+5u) : (((+4u) : (+3u)) : (+2u)) : (+1u))

:test (run `(1 (2 3) [1 (0 N.add)] 4)) ((+4u) : (+5u) : (+1u))
:test (run `(1 (2 3) [0 [[3 1 0]]] 4)) ((+4u) : (+3u) : (+2u) : (+1u))
:test (run `(1 (2 3 4) [0 [[[4 2 1 0]]]] 5)) ((+5u) : (+4u) : (+3u) : (+2u) : (+1u))

# ======== #
# EXAMPLES #
# ======== #

:test (run `(1 2 3 dup dup drop)) ((+3u) : (+3u) : (+2u) : (+1u))
:test (run `(2 dup add)) ((+4u) :)
:test (run `(2 dup add 9 sub dup mul)) ((+25u) :)

main [[0]]
